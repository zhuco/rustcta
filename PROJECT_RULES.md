# RustCTA 项目开发规范

## 项目概述

RustCTA 是一个基于 Rust 开发的加密货币量化交易系统，支持多种交易策略和多交易所对接。项目采用模块化架构，具有高性能、类型安全和并发处理能力。

## 项目结构

```
src/
├── bin/                    # 可执行文件和测试工具
│   ├── test_config.rs     # 配置测试工具
│   └── test_symbol.rs     # 交易对解析测试
├── config/                 # 配置模块
│   ├── api_config.rs      # API配置结构
│   ├── endpoints.rs       # 交易所端点配置
│   ├── strategy_config.rs # 策略配置结构
│   └── mod.rs
├── exchange/               # 交易所接口模块
│   ├── binance.rs         # 币安交易所实现
│   ├── binance_model.rs   # 币安数据模型
│   ├── traits.rs          # 交易所通用接口
│   └── mod.rs
├── strategy/               # 交易策略模块
│   ├── funding_rate.rs    # 资金费率策略
│   ├── grid.rs            # 网格交易策略
│   ├── multi_timeframe_long.rs # 多时间框架做多策略
│   └── mod.rs
├── utils/                  # 工具模块
│   ├── order_id.rs        # 订单ID生成
│   ├── precision.rs       # 精度处理
│   ├── symbol.rs          # 交易对处理
│   ├── time.rs            # 时间工具
│   ├── value.rs           # 数值处理
│   └── mod.rs
├── error.rs                # 错误类型定义
├── logger.rs               # 日志配置
└── main.rs                 # 主程序入口
```

## 开发规范

### 1. 代码风格

#### 1.1 格式化工具
- **必须使用** `rustfmt` 进行代码格式化
- **必须使用** `clippy` 进行代码质量检查
- **推荐使用** `rust-analyzer` 进行开发时的代码分析

#### 1.2 命名规范
- **结构体**: 使用 `PascalCase`，如 `AccountInfo`、`GridStrategy`
- **函数/方法**: 使用 `snake_case`，如 `get_account_info`、`place_order`
- **变量**: 使用 `snake_case`，如 `symbol_str`、`order_id`
- **常量**: 使用 `SCREAMING_SNAKE_CASE`，如 `SHUTDOWN`、`MAX_RETRIES`
- **模块**: 使用 `snake_case`，如 `binance_model`、`strategy_config`

#### 1.3 注释规范
- **公共API**: 必须使用文档注释 `///`
- **复杂逻辑**: 使用行内注释 `//` 解释业务逻辑
- **TODO/FIXME**: 使用标准格式 `// TODO: 描述` 或 `// FIXME: 描述`

### 2. 架构设计原则

#### 2.1 模块化设计
- **单一职责**: 每个模块只负责一个特定功能
- **低耦合**: 模块间通过明确的接口交互
- **高内聚**: 相关功能集中在同一模块内

#### 2.2 错误处理
- **统一错误类型**: 使用 `AppError` 枚举处理所有错误
- **错误传播**: 使用 `?` 操作符进行错误传播
- **错误日志**: 重要错误必须记录日志

#### 2.3 异步编程
- **异步函数**: 所有IO操作必须使用异步函数
- **并发安全**: 使用 `Arc`、`Mutex` 等确保线程安全
- **资源管理**: 正确处理异步资源的生命周期

### 3. 交易所接口规范

#### 3.1 Exchange Trait
- **新增交易所**: 必须实现 `Exchange` trait 的所有方法
- **API封装**: 将交易所特定的API封装为通用接口
- **错误处理**: 将交易所错误转换为 `AppError`

#### 3.2 数据模型
- **Serde支持**: 所有数据结构必须支持序列化/反序列化
- **字段映射**: 使用 `#[serde(rename)]` 处理API字段名差异
- **类型安全**: 使用强类型而非字符串表示业务概念

### 4. 策略开发规范

#### 4.1 策略结构
- **配置分离**: 策略配置与策略逻辑分离
- **状态管理**: 明确策略的状态转换
- **错误恢复**: 实现策略级别的错误恢复机制

#### 4.2 风险控制
- **止损机制**: 所有策略必须实现止损功能
- **仓位管理**: 严格控制仓位大小
- **资金管理**: 实现资金使用限制

### 5. 配置管理

#### 5.1 配置文件
- **YAML格式**: 使用YAML作为配置文件格式
- **环境分离**: 区分开发、测试、生产环境配置
- **敏感信息**: API密钥等敏感信息单独存储

#### 5.2 配置验证
- **启动验证**: 程序启动时验证配置完整性
- **类型检查**: 使用Rust类型系统确保配置正确性
- **默认值**: 为可选配置提供合理默认值

### 6. 日志规范

#### 6.1 日志级别
- **ERROR**: 系统错误、策略失败
- **WARN**: 警告信息、异常情况
- **INFO**: 重要业务事件、策略状态变化
- **DEBUG**: 调试信息、详细执行流程

#### 6.2 日志格式
- **时间戳**: 使用毫秒级时间戳
- **上下文**: 包含策略名称、交易对等上下文信息
- **结构化**: 使用结构化日志格式便于分析

### 7. 测试规范

#### 7.1 单元测试
- **覆盖率**: 核心业务逻辑测试覆盖率不低于80%
- **测试命名**: 使用描述性的测试函数名
- **测试数据**: 使用真实但脱敏的测试数据

#### 7.2 集成测试
- **API测试**: 测试与交易所API的集成
- **策略测试**: 测试策略的完整执行流程
- **配置测试**: 测试配置加载和验证

### 8. 性能优化

#### 8.1 内存管理
- **避免克隆**: 尽量使用引用而非克隆
- **生命周期**: 明确数据的生命周期
- **缓存策略**: 合理使用缓存减少API调用

#### 8.2 并发优化
- **异步IO**: 所有网络操作使用异步IO
- **连接池**: 复用HTTP连接
- **批量操作**: 支持批量下单等操作

### 9. 安全规范

#### 9.1 API安全
- **密钥管理**: API密钥不得硬编码
- **签名验证**: 正确实现API签名机制
- **权限控制**: 使用最小权限原则

#### 9.2 数据安全
- **敏感数据**: 不在日志中输出敏感信息
- **传输安全**: 使用HTTPS/WSS进行数据传输
- **存储安全**: 敏感配置文件设置适当权限

### 10. 版本管理

#### 10.1 Git规范
- **提交信息**: 使用清晰的提交信息描述变更
- **分支策略**: 使用feature分支进行功能开发
- **代码审查**: 重要变更必须经过代码审查

#### 10.2 版本发布
- **语义版本**: 遵循语义化版本规范
- **变更日志**: 维护详细的变更日志
- **向后兼容**: 保持API的向后兼容性

### 11. 部署规范

#### 11.1 环境配置
- **容器化**: 支持Docker容器化部署
- **跨平台**: 支持Linux、Windows、macOS
- **依赖管理**: 明确列出所有依赖项

#### 11.2 监控告警
- **健康检查**: 实现服务健康检查接口
- **指标监控**: 暴露关键业务指标
- **异常告警**: 实现异常情况的告警机制

## 开发流程

### 1. 新功能开发
1. 创建feature分支
2. 编写功能代码
3. 添加单元测试
4. 运行代码检查工具
5. 提交代码并创建PR
6. 代码审查
7. 合并到主分支

### 2. Bug修复
1. 创建bugfix分支
2. 定位并修复问题
3. 添加回归测试
4. 验证修复效果
5. 提交代码并创建PR
6. 代码审查
7. 合并到主分支

### 3. 发布流程
1. 更新版本号
2. 更新变更日志
3. 运行完整测试套件
4. 创建发布标签
5. 构建发布包
6. 部署到生产环境

## 常见问题解决

### 1. Serde字段映射问题
- **问题**: API返回字段名与Rust字段名不匹配
- **解决**: 使用 `#[serde(rename = "actual_field_name")]`
- **注意**: `camelCase` 转换有限制，特殊情况需手动指定

### 2. 异步生命周期问题
- **问题**: 异步函数中的引用生命周期
- **解决**: 使用 `Pin<Box<dyn Future>>` 或 `async-trait`
- **注意**: 避免在异步函数中使用复杂的生命周期

### 3. 错误处理链
- **问题**: 错误信息丢失或不清晰
- **解决**: 使用 `thiserror` 创建错误链
- **注意**: 保留原始错误信息用于调试

## 工具推荐

### 开发工具
- **IDE**: VS Code + rust-analyzer
- **调试**: LLDB/GDB
- **性能分析**: cargo flamegraph

### 代码质量
- **格式化**: rustfmt
- **静态分析**: clippy
- **测试覆盖**: cargo tarpaulin

### 部署工具
- **容器**: Docker
- **编排**: Docker Compose
- **监控**: Prometheus + Grafana

---

**注意**: 本规范是活文档，会根据项目发展不断更新。所有开发者都应该遵循这些规范，确保代码质量和项目的可维护性。